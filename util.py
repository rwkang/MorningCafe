# 2025.02.12 Youtube 영상 제작을 위한 util 모음.
# 2025.03.02 BTS IDOL 가사 및 개사
"""
BTS "Idol" 전체 가사 (영어 부분 한국어 번역)
[Intro]
Uh, uh, uh, uh, uh, uh, uh
Uh, uh, uh, uh, uh, uh, uh
(번역 불필요: 단순 음성 표현)
[Verse 1: RM, J-Hope]
I can call you liar                     You can call me artist
                                        (나를 예술가라고 불러도 돼)
I can call you psycho                   You can call me idol
                                        (나를 아이돌이라고 불러도 돼)
아님 어떤 다른 뭐라 해도
I don’t care
                                        (난 신경 안 써)
I despise you                           I’m proud of it
                                        (난 자랑스러워)
넌 평생 구속                             난 자유롭네
No more irony
                                        (더 이상 아이러니는 없어)
입만 열면 거짓말만                           나는 항상 나였기에
[Refrain: Suga, RM]
평생 어둠속에서, 너는 매일 잠못 자고 있네          손가락질 해, 나는 전혀 신경 쓰지 않네
너를 위했던 너의 그 잘못된 인식 속에              나를 욕하는 너의 그 이유가 뭐든 간에
You know what you are, You know what you are    I know what I am, I know what I want
                                                (나는 내가 누군지 알아, 내가 원하는 게 뭔지 알아)
You never gon' change, You never gon' trade     I never gon’ change, I never gon’ trade
                                                (난 절대 변하지 않을 거야, 절대 바꾸지 않을 거야)




(Trade off)
(타협하지 않아)
[Pre-Chorus: V, RM, Jimin]
뭐들이 많이 챱챱, 덥석덥석 (Talkin’, talkin’, talkin’)
I do what I do, 그니까 넌 너나 잘해
You can’t stop me lovin’ myself
(넌 날 사랑하는 걸 막을 수 없어)
[Chorus: Jungkook, V, Jimin, Jin]
(호 호) 얼쑤 좋다
You can’t stop me lovin’ myself
(넌 날 사랑하는 걸 막을 수 없어)
(호 호) 지화자 좋다
You can’t stop me lovin’ myself
(넌 날 사랑하는 걸 막을 수 없어)
[Post-Chorus: All, Jungkook]
Oh-oh-oh-oh
Oh-oh-oh-oh-oh
Oh-oh-oh-oh
덩기덕 쿵더러러 (전통 장구 소리)
얼쑤
Oh-oh-oh-oh
Oh-oh-oh-oh-oh
Oh-oh-oh-oh
덩기덕 쿵더러러 (전통 장구 소리)
얼쑤
[Verse 2: J-Hope, Suga]
Face off, 마치 ousam, ay
(대결해, 마치 ousam처럼, ay)
Top star with that spotlight, ay
(스포트라이트를 받는 톱스타, ay)
때론 슈퍼히어로가 돼
돌려대 네 석양을
Anpanman
(안팎맨 – 일본 만화 캐릭터)
24/7, 365
혼란스러운 건 내 특권
I do my thang, I love myself
(난 내 일을 해, 난 나를 사랑해)
[Refrain: Jungkook, Jimin, V]
I love myself, I love my fans
(난 나를 사랑해, 내 팬들을 사랑해)
Love my dance and my what
(내 춤과 내 모든 것을 사랑해)
내 속안엔 몇 십 몇 백명의 내가 있어
오늘 또 다른 날 맞이해
어차피 전부 다 나이기에
고민보다는 걍 달리네
Runnin’ man, runnin’ man, runnin’ man
(달리는 사람, 달리는 사람, 달리는 사람)
[Pre-Chorus: Jin, RM, Jimin]
뭐들이 많이 챱챱, 덥석덥석 (Talkin’, talkin’, talkin’)
I do what I do, 그니까 넌 너나 잘해
You can’t stop me lovin’ myself
(넌 날 사랑하는 걸 막을 수 없어)
[Chorus: Jungkook, V, Jimin, Jin]
(호 호) 얼쑤 좋다
You can’t stop me lovin’ myself
(넌 날 사랑하는 걸 막을 수 없어)
(호 호) 지화자 좋다
You can’t stop me lovin’ myself
(넌 날 사랑하는 걸 막을 수 없어)
[Post-Chorus: All, Jungkook]
Oh-oh-oh-oh
Oh-oh-oh-oh-oh
Oh-oh-oh-oh
덩기덕 쿵더러러 (전통 장구 소리)
얼쑤
Oh-oh-oh-oh
Oh-oh-oh-oh-oh
Oh-oh-oh-oh
덩기덕 쿵더러러 (전통 장구 소리)
얼쑤
[Bridge: Jimin, Jungkook, Jin]
I’m so fine wherever I go
(어디를 가든 난 괜찮아)
가끔 멀리 돌아가도
It’s okay, I’m in love with my-myself
(괜찮아, 난 나 자신을 사랑해)
It’s okay, 난 이 순간 행복해
[Chorus: Jungkook, V, Jimin, Jin]
(호 호) 얼쑤 좋다
You can’t stop me lovin’ myself
(넌 날 사랑하는 걸 막을 수 없어)
(호 호) 지화자 좋다
You can’t stop me lovin’ myself
(넌 날 사랑하는 걸 막을 수 없어)
[Post-Chorus: All, Jungkook]
Oh-oh-oh-oh
Oh-oh-oh-oh-oh
Oh-oh-oh-oh
덩기덕 쿵더러러 (전통 장구 소리)
얼쑤
Oh-oh-oh-oh
Oh-oh-oh-oh-oh
Oh-oh-oh-oh
덩기덕 쿵더러러 (전통 장구 소리)
얼쑤


"""


import os
import inspect
import psutil
import pyautogui
import time
import ctypes
import keyboard
import cv2
import logging
import numpy as np

from PIL import Image, ImageGrab
from datetime import datetime

# todo: 2025.02.13 Conclusion. [main.py]에서 호출하는데,
#       여기서 다시 아래와 같이 [import.gv]를 호출하면, 파일 간 서로 엉킴 현상으로 에러가 발생한다.
#       import gv

# from inspect import currentframe  #, getframeinfo

# 2024.07.25 Added. 현재 프로그램 파일의 현재 라인 번호.
def get_info():
    stack = inspect.stack()
    frame = stack[1]
    filename = frame.filename
    lineno = frame.lineno
    # return filename, lineno # full path 가져 오기
    return os.path.basename(filename), lineno # 파일 이름만 가져 오기.

    # basename = os.path.basename(filename) # 파일 이름
    # dirname = os.path.basename(os.path.dirname(filename)) # 해당 파일이 속한 마지막 폴더 이름
    # return dirname, basename, lineno # 최종 폴더, 파일명, 라인 번호

# print(get_info(), "get_info() test...")

# 2025.02.12 Added. 오늘 날짜 폴더 확인 및 생성
def check_directory(PATH_YM, STR_YMD):
    # 현재 날짜를 "YYYYMMDD" 형식으로 가져오기
    # str_ymd = datetime.now().strftime("%Y%m%d") # 찰라의 순간에 혹시 날짜가 변경될 수 있으니, 파라미터로 받게 한다.
    # 확인할 경로 설정
    full_path = os.path.join(PATH_YM, STR_YMD)
    print(get_info(), "PATH_YM: ", PATH_YM, ", full_path: ", full_path)
    # 디렉터리 존재 여부 확인 및 생성
    if not os.path.exists(full_path):
        os.makedirs(full_path)
        print(get_info(), "작업 폴더를 성공적으로 만들었습니다.")
        return True
    else:
        print(get_info(), f"디렉터리가 이미 있습니다. {full_path}")
        return False

    # # 한번 더 체크
    # if not os.path.exists(full_path):
    #     print(get_info(), f"디렉터리를 만들지 못했습니다. {full_path}")
    #     return False
    # return True


# 2025.02.11 Added. 윈도우 10 에서, 현재 크롬 브라우져가 열려 있는지 확인
def is_chrome_running():
    # 실행 중인 모든 프로세스 확인
    for process in psutil.process_iter(['name']):
        if process.info['name'] == 'chrome.exe': # Chrome 브라우저
            return True
    return False

# 2025.02.11 Added. 브라우저 화면에서 스크롤을 최대한 위로 올리는 펑션
def scroll_up():
    i = 1
    while i < 20: #True: # 일단 20번만 하게 하고, True 사용을 위해서는 [무한 루프]를 고려 하여,공통적으로 빠질 수 있는 로직을 만들어야 한다.
        # 스크롤을 아래로 내림.
        pyautogui.scroll(100) # 100 : scroll down
        time.sleep(0.2) # 잠시 대기
        i += 1

        # 스크롤 후에 스크롤 위치를 확인 (스크롤이 끝났는지 확인)
        # 스크롤 후 페이지가 더 이상 아래로 내려갈 수 없으면 종료
        # 아래 조건은 화면의 크기나 웹사이트에 따라 조정이 필요할 수 있음
        # 예시로 임의의 조건을 사용

        ############################# 실제로는 특정 요소가 화면에 보이는지 확인하는 로직이 필요함
        # 예를 들어, 특정 요소가 더 이상 보이지 않으면 종료
        # if not pyautogui.locateOnScreen('element_image.png'):
        #     break

# 2025.02.11 Added. 브라우저 화면에서 스크롤을 최대한 아래로 내리는 펑션
def scroll_down():
    i = 1
    while i < 20: #True: # 일단 20번만 하게 하고, True 사용을 위해서는 [무한 루프]를 고려 하여,공통적으로 빠질 수 있는 로직을 만들어야 한다.
        # 스크롤을 아래로 내림.
        pyautogui.scroll(-100) # 100 : scroll down
        time.sleep(0.2) # 잠시 대기
        i += 1

        # 스크롤 후에 스크롤 위치를 확인 (스크롤이 끝났는지 확인)
        # 스크롤 후 페이지가 더 이상 아래로 내려갈 수 없으면 종료
        # 아래 조건은 화면의 크기나 웹사이트에 따라 조정이 필요할 수 있음
        # 예시로 임의의 조건을 사용

        ############################# 실제로는 특정 요소가 화면에 보이는지 확인하는 로직이 필요함
        # 예를 들어, 특정 요소가 더 이상 보이지 않으면 종료
        # if not pyautogui.locateOnScreen('element_image.png'):
        #     break


# 'capslock' 키가 눌려져 있는지 확인.
def is_capslock_on():
    return True if ctypes.WinDLL("User32.dll").GetKeyState(0x14) else False

def turn_capslock_on():
    if not is_capslock_on():
        pyautogui.press("capslock")

def turn_capslock_off():
    if is_capslock_on():
        pyautogui.press("capslock")


# 2025.02.11 Added. 파일 존재 확인
def check_file_exists(file_name):
    # 파일 존재 확인
    print(get_info(), file_name, ", 이 파일이 있는지 확인 합니다...")
    if os.path.exists(file_name):
        return True
    return False

# 2025.02.13 Added. x, y 좌표 값을 리턴하여, 호출한 쪽에서, 좌표 값을 조정하여, 클릭하게 하는 펑션을 추가한다.
def find_image_position(image_file, screen_to_find_image):
    # 7. 뤼튼, 복사 아이콘 찾기
    # 7.1 스크린 샷을 찍고 이미지 찾기
    screenshot = pyautogui.screenshot()
    # 7.2 스크린 샷을 저장
    screenshot.save(screen_to_find_image)

    # 7.3 OpenCV에서 BGR 형식으로 변환
    # screenshot_np = np.array(screenshot) # 파일 저장 안 하고 처리하는 방식.
    # screenshot_bgr = cv2.cvtColor(screenshot_np, cv2.COLOR_RGB2BGR)
    screenshot_cv = cv2.imread(screen_to_find_image)

    # 7.4 복사 아이콘 이미지 (icon_copy.png) 파일 로드
    template = cv2.imread(image_file)

    # 7.5 이미지 찾기
    # result = cv2.matchTemplate(screenshot_bgr, template, cv2.TM_CCOEFF_NORMED) # 파일 저장 안 하고 처리하는 방식.
    result = cv2.matchTemplate(screenshot_cv, template, cv2.TM_CCOEFF_NORMED)
    threshold = 0.8 # 임계 값
    locations = np.where(result >= threshold)

    # 7.6 이미지 발견되면 클릭.
    if len(locations[0]) > 0:
        # 7.6.1 첫번째 발견된 위치
        y, x = locations[0][0], locations[1][0]
        center_img_x = x + template.shape[1] // 2
        center_img_y = y + template.shape[0] // 2
        print(get_info(), "center_img_x: ", center_img_x)
        print(get_info(), "center_img_y: ", center_img_y)
    else:
        center_img_x = -1
        center_img_y = -1
        print(get_info(), "center_img_x: -1, center_img_y: -1, 이미지를 찾을 수 없습니다!!!")

    return center_img_x, center_img_y

# 윈도우 탐색기 팝업 창에서, 경로 클릭하기.
def __windows_explorer_path(DOWNLOAD_PATH, SCREEN_TO_FIND_DOWNLOAD_PATH):
    k = 1
    while True:
        # 윈도우 탐색기 창에서 경로 에디트 박스
        image_file = DOWNLOAD_PATH
        screen_to_find_image = SCREEN_TO_FIND_DOWNLOAD_PATH
        if not find_image(image_file, screen_to_find_image):
            print(get_info(), "윈도우 탐색기 팝업 창 경로 이미지를 찾을 수 없습니다! 10초 대기 후 loop... k: ", k)
            # return False  # 프로그램 종료하고, [에러 카톡 발송] 한다.
            # return # 프로그램 종료가 아니고, 계속 진행한다. 이미 [편집 화면 부분]이 감춰져 있다는 의미임.
            time.sleep(10)  # 2025.02.13 Added. 파일 저정을 위한 [탐색기] 창이, 간혹 엄청 느리게 나오네.
            k += 1
        else:
            print(get_info(), "탐색기 팝업 창에서 [경로]를 클릭하였습니다!!!")
            time.sleep(1)
            break

    return True

# 윈도우 탐색기 팝업 창에서, [저장] 버튼 클릭하고, 만약 [이미 있음 팝업 창]이 나오면, [확인] 버튼 클릭.
def __windows_explorer_save(DOWNLOAD_SAVE, SCREEN_TO_FIND_DOWNLOAD_SAVE,
                            DOWNLOAD_ALREADY_IMAGE, SCREEN_TO_FIND_DOWNLOAD_ALREADY_IMAGE):
    # 윈도우 탐색기 창에서, 저장 버튼
    image_file = DOWNLOAD_SAVE
    screen_to_find_image = SCREEN_TO_FIND_DOWNLOAD_SAVE
    k = 1
    while True:
        if not find_image(image_file, screen_to_find_image):
            print(get_info(), "윈도우 탐색기 팝업 창에서 [저장] 버튼을 찾을 수 없습니다. 10초 대기 후 loop... k: ", k)
            # return False  # 프로그램 종료하고, [에러 카톡 발송] 한다.
            # return # 프로그램 종료가 아니고, 계속 진행한다. 이미 [편집 화면 부분]이 감춰져 있다는 의미임.
            time.sleep(10)
            k += 1
        else:
            print(get_info(), "탐색기 팝업 창에서 [저장] 버튼을 클릭하였습니다!!!")
            time.sleep(3)

            # todo: 2025.02.13 위 A.와 B. 다시 확인해 볼 것.
            #       1. [파일 이미 있음] 또는 [파일 없음] 팝업 창이 나오고, 안 나오고
            #       2. 나온 후, [파일 이미 있음] => [Yes] 또는 [파일 없음] => [확인] 버튼 클릭 등 처리...
            # todo: 여기서만 [True] 일 때, 프로그램을 종료하게 한다. ∵) 현재 폴더에 이미지 [파일 없음] 이므로...
            image_file = DOWNLOAD_ALREADY_IMAGE
            screen_to_find_image = SCREEN_TO_FIND_DOWNLOAD_ALREADY_IMAGE
            # todo: [이미 있음 팝업 창]이 안 나오거나, 나왔는데 정상적으로 [덮어쓰기 성공] 했거나 하면, False. True 아님에 특히 주의.
            if not find_image(image_file, screen_to_find_image):  # todo: [이미 있음 팝업 창]이 나왔다
                print(get_info(), "[파일 이미 있음] 팝업 창이 나오지 않고, 정상적으로 진행합니다!!!")
            else:  # todo: [이미 있음 팝업 창]이 안 나왔다면, 지극히 정상적으로 [저장] 되었다는 얘기.
                print(get_info(), f"정상적으로 저장되었습니다.")

            break

    return True

# 2025.02.11 Added. 현재 화면 캡쳐/저장 후, 특정 이미지 파일 찾기
def find_image(image_file, screen_to_find_image):

    print(get_info(), "image_file: ", image_file)
    print(get_info(), "screen_to_find_image: ", screen_to_find_image)

    # 7. 뤼튼, 복사 아이콘 찾기
    # 7.1 스크린 샷을 찍고 이미지 찾기
    screenshot = pyautogui.screenshot()
    # 7.2 스크린 샷을 저장
    screenshot.save(screen_to_find_image)

    # 7.3 OpenCV에서 BGR 형식으로 변환
    # screenshot_np = np.array(screenshot) # 파일 저장 안 하고 처리하는 방식.
    # screenshot_bgr = cv2.cvtColor(screenshot_np, cv2.COLOR_RGB2BGR)
    screenshot_cv = cv2.imread(screen_to_find_image)

    # 7.4 복사 아이콘 이미지 (icon_copy.png) 파일 로드
    template = cv2.imread(image_file) # hailuo_camera_debut.png hailuo_camera_debut.png

    # 7.5 이미지 찾기 : screen_to_find_hailuo_camera_12345.png vs screen_to_find_hailuo_camera_12345.png
    try:
        # result = cv2.matchTemplate(screenshot_bgr, template, cv2.TM_CCOEFF_NORMED) # 파일 저장 안 하고 처리하는 방식.
        result = cv2.matchTemplate(screenshot_cv, template, cv2.TM_CCOEFF_NORMED)
    except cv2.error as e:
        print(get_info(), "cv2.error: ", e)
        # Check if file exists
        if not os.path.exists(image_file):
            print(f"Template image file not found: {image_file}")
        # Check image loading
        elif template is None:
            print(f"Failed to load template image: {image_file}")
        else:  # Check dimensions and types
            print(f"Screenshot shape: {screenshot_cv.shape}, dtype: {screenshot_cv.dtype}")
            print(f"Template shape: {template.shape}, dtype: {template.dtype}")
        return False
    except ValueError as e:
        print(get_info(), "ValueError: ", e)
        return False
    except Exception as e:
        print(get_info(), "Exception: ", e)
        return False

    threshold = 0.8 # 임계 값
    locations = np.where(result >= threshold)

    filename = os.path.basename(image_file)

    # 7.6 이미지 발견되면 클릭.
    if len(locations[0]) > 0:
        # 7.6.1 첫번째 발견된 위치
        y, x = locations[0][0], locations[1][0]
        center_img_x = x + template.shape[1] // 2
        center_img_y = y + template.shape[0] // 2
        print(get_info(), "center_img_x: ", center_img_x)
        print(get_info(), "center_img_y: ", center_img_y)

        # 7.6.2 마우스를 해당 위치로 이동하고 클릭
        if filename == 'ideogram_cover.png':  # gv.ideogram_cover : 이런식으로 [gv.py]를 또 불러 사용하면, 파일 간 엉킴 현상으로 에러가 발생한다.
            center_img_y = center_img_y - 30
        if filename == 'download_path.png' or filename == 'open_path.png':  # x,y 값 우/하 이동, 클릭하면, [폴더 경로] 부분이다.
            center_img_x = center_img_x + 150
            center_img_y = center_img_y + 40
        if filename == 'download_already_image.png':  # x, y 값 우/하 이동 [Yes] 버튼 클릭.
            center_img_x = center_img_x + 185
            center_img_y = center_img_y + 50
            pyautogui.moveTo(center_img_x, center_img_y)
            pyautogui.click()
            print(get_info(), "[파일 이미 있음] 팝업 창에서, [Yes] 버튼 클릭하여 덮어 쓰기 했습니다!!!")
            # print(get_info(), "여기는 클릭할 필요가 없습니다. 그냥 진행 합니다!!!")
            return False
        if filename == 'file_doesnt_exist.png':  # 그냥 ['enter'] === > [확인] 버튼 1개 뿐이다.
            print(get_info(), "동영상을 만들 [이미지 파일]이 없다는 팝업 창이 떳습니다.")
            pyautogui.moveTo(center_img_x, center_img_y, 1)
            pyautogui.click()
            pyautogui.press('enter') # [파일 없음] 팝업 창에, [확인] 버튼 클릭 효과.
            return False
        # 2025.02.19 Added. IDEOGRAM 이미지 생성 완료 아이콘 찾기 후 클릭 없이 return.
        if filename == 'ideogram_generation_complete.png':  # 그냥 ['enter'] === > [확인] 버튼 1개 뿐이다.
            print(get_info(), "IDEOGRAM 이미지 생성 완료 아이콘이, 타이틀 바에 떳습니다.")
            pyautogui.moveTo(center_img_x, center_img_y, 1)
            time.sleep(1)
            # pyautogui.click() # todo: 여기서는 [클릭 안 함]에 특히 주의.
            # pyautogui.press('enter') # [파일 없음] 팝업 창에, [확인] 버튼 클릭 효과.
            return True
        # 2025.03.18 Added. hailuo_video_reedit.png, 동영상 생성 시 [프롬프트 에러] 발생으로 [Re-edit] 버튼 나올 때.
        #                   그런데, 이 버튼이 현재 영상(첫번째) 화면에서만 나오는지 확인...
        if filename == 'hailuo_video_reedit.png':
            if center_img_y < 0: # 0 보다 큰 값이면, 이미 지난 동영상 화면에 [Re-edit] 버튼이다.
                print(get_info(), "HAILUO Video 생성 시 프롬프트 문제로 [Re-edit] 버튼이 떳습니다. 다시 생성합니다!!!")
                pyautogui.moveTo(center_img_x, center_img_y, 1)
                time.sleep(1)
                # pyautogui.click() # todo: 여기서는 [클릭 안 함]에 특히 주의.
                # pyautogui.press('enter') # [파일 없음] 팝업 창에, [확인] 버튼 클릭 효과.
                return False

        pyautogui.moveTo(center_img_x, center_img_y)
        pyautogui.click()
        print(get_info(), "이미지를 찾아 클릭했습니다!!!")
        time.sleep(1)
        return True

    else:
        if filename == 'file_doesnt_exist.png' or filename == 'download_already_image.png':
            if filename == 'download_already_image.png':
                print(get_info(), "[파일 이미 있음] 팝업 창이 나오지 않고, 정상적으로 진행합니다!!!")
            if filename == 'file_doesnt_exist.png':
                print(get_info(), "[파일 없음] 팝업 창이 나오지 않고, 정상적으로 진행합니다!!!")
            return False
        else:
            print(get_info(), "center_img_x: -1, center_img_y: -1, 이미지를 찾을 수 없습니다!!!")
            time.sleep(3)
            return False # 프로그램 종료하고, [에러 카톡 발송] 한다.

# 2025.02.20 Added. 동영상 생성, Hailuo AI 현재 화면에서, 불러온 이미지와 생성된 영상 첫프레임이, 현재 화면에 있는지 확인 한다.
def find_image_twins(image_file, screen_to_find_image):

    print(get_info(), "image_file: ", image_file)

    # 스크린 샷 찍기
    screenshot = pyautogui.screenshot()
    screenshot.save(screen_to_find_image)

    # OpenCV에서 이미지 로드
    screenshot_cv = cv2.imread(screen_to_find_image)
    template = cv2.imread(image_file)

    # 이미지 찾기
    result = cv2.matchTemplate(screenshot_cv, template, cv2.TM_CCOEFF_NORMED)
    threshold = 0.8 # 임계 값
    locations = np.where(result >= threshold)

    # 발견된 위치의 리스트
    found_locations = []
    for pt in zip(*locations[::-1]): # (x, y) 좌표로 변환
        found_locations.append(pt)

    # 2개 이상의 이미지 발견 확인
    if len(found_locations) >= 2:
        for i in range(2): # 첫번째와 두번째 이미지
            x, y = found_locations[i]
            center_img_x = x + template.shape[1] // 2
            center_img_y = y + template.shape[0] // 2
            print(get_info(), f"이미지 찾음 {i + 1}, 위치: ", center_img_x, center_img_y)
            # 이미지 등을 클릭하려면, 여기 아래에서 코딩...
        return True

    else:
        print(get_info(), "동영상 생성이 아직 진행 중 입니다. 잠시만 기다려 주세요...")
        time.sleep(2)
        return False  # 프로그램 종료하고, [에러 카톡 발송] 한다.

    # todo: 아래 코드는 간단하게 처리 하는 방식 ***
    '''
    # 이미지의 위치를 찾음
    positions = pyautogui.locateAllOnScreen(image_file)

    # 위치 리스트를 생성하여 갯수 확인
    positions_list = list(positions)

    # 갯수 확인
    if len(positions_list) >= 2:
        print(get_info(), f"{image_file}가 {len(positions_list)}개 있습니다. 동영상 생성이 완료되었습니다!")
        time.sleep(2)
        return True

    else:
        print(get_info(), "동영상 생성이 아직 진행 중 입니다. 잠시만 기다려 주세요...")
        time.sleep(90)
        return False  # 프로그램 종료하고, [에러 카톡 발송] 한다.
    '''


# 2025.02.11 Added. 현재 키보드 상태가, 한글인지 영문인지 확인하여, 한글이면 강제로 [영문]으로 변경.
# 참고로, 아래 is_hangul() 함수로는 작동이 안 되는 관계로, 이미지(icon_hangul.png) 파일을 비교하여, 아이콘을 클릭하게 한다.
# def check_icon_at_position(x, y, icon_file, icon_file_pos, background_color=(255,255,255), tolerance=0):
def check_icon_at_position(x, y, icon_file, icon_file_pos, tolerance):
    # 화면의 특정 위치 이미지 가져오기
    screen = ImageGrab.grab()
    # 아이콘 이미지 로드
    icon = Image.open(icon_file)
    # 아이콘 크기
    icon_width, icon_height = icon.size
    print(get_info(), "icon_file: ", icon_file)
    print(get_info(), "x, y: ", x, y)
    pyautogui.moveTo(x, y, 1)
    time.sleep(5)
    print(get_info(), "icon_width, icon_height: ", icon_width, icon_height)
    # 특정 좌표에서 아이콘 영역의 화면 가져오기
    screen_region = screen.crop((x, y, x + icon_width, y + icon_height)).convert("RGBA")

    # 화면 저장 : 꼭 저장 안 해도 된다. 참고로 확인해 보고자 저장해 준다.
    screen_region.save(icon_file_pos)

    print(get_info(), "list(icon.getdate(): ", list(icon.getdata()))
    print(get_info(), "list(screen_region.getdate(): ", list(screen_region.getdata()))

    # 아이콘과 스크린 영역 비교
    icon_data = list(icon.getdata())
    screen_region_data = list(screen_region.getdata())

    # 반드시 비교 전에, 색상 차이를 허용 해야 한다.
    idx = 0
    # for index, icon_pixel, screen_region_pixel in enumerate(zip(icon_data, screen_region_data)):
    for icon_pixel, screen_region_pixel in zip(icon_data, screen_region_data):
        if not all(abs(icon_pixel[i] - screen_region_pixel[i]) <= tolerance for i in range(3)):
            print(get_info(), "idx: ", idx, ", icon_data_count: ", len(icon_data))
            # print(get_info(), "tolerance: ", tolerance)
            print(get_info(), "icon_pixel[0]: ", icon_pixel[0])
            print(get_info(), "icon_pixel[1]: ", icon_pixel[1])
            print(get_info(), "icon_pixel[2]: ", icon_pixel[2])
            print(get_info(), "screen_region_pixel[0]: ", screen_region_pixel[0])
            print(get_info(), "screen_region_pixel[1]: ", screen_region_pixel[1])
            print(get_info(), "screen_region_pixel[2]: ", screen_region_pixel[2])
            print(get_info(), "icon_pixel[0] - screen_region_pixel[0]: ", icon_pixel[0] - screen_region_pixel[0])
            print(get_info(), "icon_pixel[1] - screen_region_pixel[1]: ", icon_pixel[1] - screen_region_pixel[1])
            print(get_info(), "icon_pixel[2] - screen_region_pixel[2]: ", icon_pixel[2] - screen_region_pixel[2])
            print(get_info(), "리턴 값은 False")
            return False
        idx += 1
    print(get_info(), "리턴 값은 True")
    return True

    # 색상까지 모두 동일할 때.
    # if list(screen_region.getdata()) == list(icon_rgb.getdata()):
    #     print(get_info(), "2개 이미지가 동일합니다!!!")
    #     return True
    # return False

# 바탕색을 투명하게 처리한 후 이미지를 저장
def save_image_with_transparency(image, background_color, icon_trs_file):
    # 이미지의 모든 픽셀을 순회
    for x in range(image.width):
        for y in range(image.height):
            pixel = image.getpixel((x, y))
            if pixel[:3] == background_color: # 바탕색과 동일한 픽셀을 찾음.
                image.putpixel((x, y), (pixel[0], pixel[1], pixel[2], 0)) # 알파 값을 0으로 설정

    # 투명하게 처리된 이미지를 저장
    image.save(icon_trs_file)


# 2025.02.11 Added. 현재 키보드 상태가, 한글인지 영문인지 확인하여, 한글이면 강제로 [영문]으로 변경.
# 2025.02.11 Conclusion. 아래 함수는 작동이 안 되네...
def is_hangul():
    # 현재 키보드 상태 확인
    state = ctypes.windll.user32.GetKeyboardLayout(0)
    print(get_info(), "state: ", state)
    return state & 0xFFFF == 0x0412  # 0x0412는 한글 키보드 레이아웃 == 68289554
    # return state & 0xFFFF == 0x0409  # 0x0409는 영문 키보드 레이아웃 == 1033

# def switch_to_english():
    # Alt+Shift 언어 전환
    # pyautogui.press('alt', 'shift')
    # '한/영' 언어 전환
    # pyautogui.press('vk_15') # vk_15 : "한/영" 키의 가장 키 코드.
    # keyboard.press_and_release('vk_rmenu') # 오른쪽 "alt" 키 코드. k eyboard.press_and_release() 함수를 사용함에 주의.
    # keyboard.press_and_release('right alt') # 오른쪽  . "alt" 키 코드. keyboard.press_and_release() 함수를 사용함에 주의.
    # keyboard.press_and_release('alt gr') # 오른쪽  ."alt" 키 코드. keyboard.press_and_release() 함수를 사용함에 주의.
    # pyautogui.press('right alt') # 또는 'alt gr'
    # pyautogui.press('alt gr')
    # pyautogui.press('hanja')
    # pyautogui.press('hangul')

    # pyautogui.moveTo(center_x + 780, center_y + 520, 1)
    # pyautogui.click()
    # time.sleep(0.2)

    # state = ctypes.windll.user32.GetKeyboardLayout(0)
    # print(get_info(), "영문 state: ", state)

# pyautogui.position() # 마우스 포인트 추출: x, y 좌표 값.
"""
#prepare
#0. import pyautogui, time
#1. get naver login button position to "login_btn"
#2. get id input position to "id_position"
#3. get final login button position to "final_login_btn"
#4. set naver_id and naver_pw

login_btn = (1094, 615)
id_position = (573, 476)
final_login_btn = (425, 626)

naver_id = "myid123"
naver_pw = "mypw321"

pag.click(login_btn) #click login button
time.sleep(1) #delay for 1 sec

pag.click(id_position) # click id position
time.sleep(1) #delay for 1 sec

i = 0
while i < 20:
    pag.press("backspace", interval = 1)
    i = i + 1

pag.press("capslock", interval = 0.5)
pag.press("capslock", interval = 0.5)
time.sleep(1) #delay for 1 sec

pag.typewrite(naver_id, interval = 0.5)
time.sleep(1) #delay for 1 sec

pag.press("tab")
time.sleep(1) #delay for 1 sec

pag.typewrite(naver_pw, interval = 0.5)
time.sleep(1) #delay for 1 sec

pag.click(final_login_btn)
"""
